import copy
import random
import constraints

# constraints_dict is dict where keys are constraint function names
# and values are (boolean, int) tuples representing (enabled, cost)

def evaluation_func(assignment, domain, constraints_dict):
    total_cost = 0
    for key in constraints_dict.keys():
        enabled, cost = constraints_dict[key]
        if enabled:
            total_cost += getattr(constraints, key)(assignment, domain, cost)
    return total_cost

# the assignment is represented as a dict where the key is a worker
# and the value is a list of the tasks assigned to that worker

# initialize a new assignment by making sure every task has at least one worker
# more specifically, a random number of workers between 1 and len(workers)

def init_assignment(domain):
    workers, tasks = domain
    assignment = {}
    flipped_asst = {}
    for task in tasks:
        n = 1 + int(random.random() * (len(workers) - 1))
        assignment[task] = random.sample(workers, n)
    for worker in workers.keys():
        flipped_asst[worker] = []
    for task in assignment.keys():
        for worker in assignment[task]:
            flipped_asst[worker].append(task)
    return flipped_asst

# neighbors of the current assignment are generated in one of two ways:
# either remove one of a worker's assigned tasks or assign the worker a new task

# we evaluate all neighbors of the current assignment
# and then we return the "best" neighbor (with the lowest cost)

def find_best_neighbor(assignment, domain, constraints_dict, best_cost):
    workers, tasks = domain
    best_assignment = copy.deepcopy(assignment)
    for worker in assignment.keys():
        for task in tasks.values():
            new_assignment = copy.deepcopy(assignment)
            if task.name in assignment[worker]:
                new_assignment[worker].remove(task.name)
                cost = evaluation_func(new_assignment, domain, constraints_dict)
            else:
                new_assignment[worker].append(task.name)
                cost = evaluation_func(new_assignment, domain, constraints_dict)
            #print "Cost:", cost
            #print "Best Cost:", best_cost
            if cost < best_cost:
                best_cost = cost
                best_assignment = new_assignment
                #print "New assignment with cost", best_cost
                #print best_assignment
    return (best_assignment, best_cost)
    
# function to choose a random neighbor from the set
# of all possible neighbors of the current assignment

def find_random_neighbor(assignment, domain, constraints_dict):
    workers, tasks = domain
    new_assignment = copy.deepcopy(assignment)
    worker = random.choice(workers.values())
    task = random.choice(tasks.values())
    if task.name in assignment[worker.name]:
        new_assignment[worker].remove(task.name)
    else:
        new_assignment[worker].append(task.name)
    cost = evaluation_func(new_assignment, domain, constraints_dict)
    return (new_assignment, cost)

# for hill_climbing, we start with a random assignment generated by init_assignment
# then we repeatedly move from the current assignment to the best neighbor
# until we find a local maxima, which we then return as a solution

# hill climbing
def hill_climbing(domain, constraints_dict):
    assignment = init_assignment(domain)
    best_cost = float("inf")
    best_neighbor, neighbor_cost = find_best_neighbor(assignment, domain, constraints_dict, best_cost)
    while(neighbor_cost < best_cost):
        assignment = best_neighbor
        best_cost = neighbor_cost
        best_neighbor, neighbor_cost = find_best_neighbor(assignment, domain, constraints_dict, best_cost)
    print "FINAL COST", neighbor_cost
    return best_neighbor

# random restart hill climbing
def rr_hill_climbing(domain, constraints_dict):
    # SET MAX ITERATIONS HERE
    max_iters = 50
    best_result = (None, float("inf"))
    for i in xrange(max_iters):
        assignment = init_assignment(domain)
        best_cost = float("inf")
        best_neighbor, neighbor_cost = find_best_neighbor(assignment, domain, constraints_dict, best_cost)
        while(neighbor_cost < best_cost):
            assignment = best_neighbor
            best_cost = neighbor_cost
            best_neighbor, neighbor_cost = find_best_neighbor(assignment, domain, constraints_dict, best_cost)
        if neighbor_cost < best_result[1]:
            best_result = (best_neighbor, neighbor_cost)
    print "FINAL COST", best_result[1]
    return best_result[0]
    
# stochastic hill climbing
# def stoc_hill_climbing(domain, constraints_dict):
    